[require]
SPIRV YES
GL >= 3.3
GLSL >= 4.50
GL_ARB_gl_spirv
GL_ARB_separate_shader_objects

; The test uses a very simple function call in the fragment shader
; (the ambient function from the second fragment shader).
; For the moment, making the function slightly more complex (by adding
; uniforms or varyings makes testing impossible because of this glslang
; error: https://github.com/KhronosGroup/glslang/issues/1285

[vertex shader passthrough]

[fragment shader spirv]
; Automatically generated from the GLSL by shader_test_spirv.py. DO NOT EDIT
; SPIR-V
; Version: 1.0
; Generator: Khronos Glslang Reference Front End; 5
; Bound: 47
; Schema: 0
               OpCapability Shader
          %1 = OpExtInstImport "GLSL.std.450"
               OpMemoryModel Logical GLSL450
               OpEntryPoint Fragment %main "main" %out_color
               OpExecutionMode %main OriginLowerLeft
               OpSource GLSL 450
               OpName %main "main"
               OpName %ambient_f1_vf4_ "ambient(f1;vf4;"
               OpName %a "a"
               OpName %color "color"
               OpName %out_color "out_color"
               OpName %param "param"
               OpName %param_0 "param"
               OpDecorate %out_color Location 0
       %void = OpTypeVoid
          %3 = OpTypeFunction %void
      %float = OpTypeFloat 32
%_ptr_Function_float = OpTypePointer Function %float
    %v4float = OpTypeVector %float 4
%_ptr_Function_v4float = OpTypePointer Function %v4float
         %10 = OpTypeFunction %v4float %_ptr_Function_float %_ptr_Function_v4float
%_ptr_Output_v4float = OpTypePointer Output %v4float
  %out_color = OpVariable %_ptr_Output_v4float Output
  %float_0_1 = OpConstant %float 0.1
  %float_0_3 = OpConstant %float 0.3
    %float_0 = OpConstant %float 0
    %float_1 = OpConstant %float 1
         %21 = OpConstantComposite %v4float %float_0_3 %float_0 %float_0 %float_1
       %uint = OpTypeInt 32 0
     %uint_0 = OpConstant %uint 0
     %uint_1 = OpConstant %uint 1
     %uint_2 = OpConstant %uint 2
     %uint_3 = OpConstant %uint 3
       %main = OpFunction %void None %3
          %5 = OpLabel
      %param = OpVariable %_ptr_Function_float Function
    %param_0 = OpVariable %_ptr_Function_v4float Function
               OpStore %param %float_0_1
               OpStore %param_0 %21
         %24 = OpFunctionCall %v4float %ambient_f1_vf4_ %param %param_0
               OpStore %out_color %24
               OpReturn
               OpFunctionEnd
%ambient_f1_vf4_ = OpFunction %v4float None %10
          %a = OpFunctionParameter %_ptr_Function_float
      %color = OpFunctionParameter %_ptr_Function_v4float
         %14 = OpLabel
         %27 = OpAccessChain %_ptr_Function_float %color %uint_0
         %28 = OpLoad %float %27
         %29 = OpLoad %float %a
         %30 = OpFAdd %float %28 %29
         %32 = OpAccessChain %_ptr_Function_float %color %uint_1
         %33 = OpLoad %float %32
         %34 = OpLoad %float %a
         %35 = OpFAdd %float %33 %34
         %37 = OpAccessChain %_ptr_Function_float %color %uint_2
         %38 = OpLoad %float %37
         %39 = OpLoad %float %a
         %40 = OpFAdd %float %38 %39
         %42 = OpAccessChain %_ptr_Function_float %color %uint_3
         %43 = OpLoad %float %42
         %44 = OpCompositeConstruct %v4float %30 %35 %40 %43
               OpReturnValue %44
               OpFunctionEnd

[fragment shader]
#version 450

layout(location = 0) out vec4 out_color;

const vec4 color = vec4(0.3, 0.0, 0.0, 1.0);

vec4 ambient(float a, vec4 color);

void main()
{
	out_color = ambient(0.1, color);
}

[fragment shader]
#version 450

vec4 ambient(float a, vec4 color)
{
	return vec4(color.r + a, color.g + a, color.b + a, color.a);
}

[test]
draw rect -1 -1 2 2
probe all rgba 0.4 0.1 0.1 1.0
